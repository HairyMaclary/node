[for inclusion into other notes:

Function Constructors

A function constructor is a normal function that is used to create objects.  If you use the new keyword the 'this' variable points to a new empty object, and that object is returned from the function automatically. 

Because 'this' has been automaticaly created then we can attach things to it inside the function before it is returned:

    function Person (firstName, lastName) {
        this.lastName = lastName;
        this.firstName = firstName;
    }

    var john = new Person('John', 'Doe');

It's also possible to add to this object's prototype (see 'prototype chain' - in js inheritance is from other objects, not a class):

    Person.prototype.greet = function() {
        // use 'this' so that we refer to the object and not some variable
        console.log('hello ' + this.firstName + ' ' + this.lastName);
    }

The naming here is a little confusing. This prototype is the prototype of any object created from the Person function. It is not the prototype of the constructor function. So all objects created from this function constructor can have access to this greet method.

The js engine will now search down the prototype chain for this method:

    john.greet();


If you ever want to see the prototype for an object use __proto__ :

    // not recommended for produciton code
    console.log(john.__proto__);  // { greet: [function] } 




Primitive Value: any value that is not an object. These are passed by value into functions.






]

******************************************

                Node

******************************************


Javascript is quite a high level language. Functionality like memory menagement is abstracted away. Also, because js was created for use in browsers it lacks some other common functionality such as modules and sneding files around. V8 is an open source c++ applicaiton that converts JS into machine code instructions for a variety of commpn microprocessor arcitectures. It is thus a JS engine, and it also meets all the ECMA script soecifications for a JS engine. The advantage of v8 is that it has hooks so that it can be embedded in other c++ applicaitons. Node is such an application. It takes v8 and extends so that JS can be given extra functionality. This allows JS to be used outside of the browser. In particular it gives JS enough funcitonality to be used on a server (the client-server model is common, and the best example is on the internet, which used http to communicate between clients and servers). A server is connected to the internet and offers services.



Modules 
----------------------------------

A module is a reusable block of code whose existence does not accidentially impact other code. Javascript did not orignally have this feature (although ECMAscript 6 spec does require it now). Node does this with 'CommonJS modules'.

CommonJS modules are an agreed upon standard for how code modules should be structured. 

Node supplies a built in function for importing modules called 'require('./filePath')'. 

This will make any code that is invoked within that required file run. However any functions from that file can't just be called. This is to prevent naming collisions.

So to call functions from the required file we have to use 'module.exports' in the required file. 

greet.js:

    // this line runs when greet is required in app.js. You don't even need to assign require to a variable
    console.log('Due to require(), this appears automatically in app.js');

    // this will not run in app.js unless we assign it to module.exports.
    var greet = function() {
        console.log("hello");
    };

    module.exports = greet;

app.js

    // to just get that first line from greet running
    // require('./greet');

    // now we use the idea that the require function returns 
    // module.exports.
    const greet = require('./greet');

    greet();

To explain how modules work in nodejs we first have to look at scope.

Scope: where in code you have access to a particular variable or function. 

Scope example with an IIFE, that shows how JS devs once faked up modules:

    var firstName = 'Jane';

    // the () around the function turn it into an expression that the engine
    // then holds and waits to see what you do with it. We execute it.
    
    (function () {
        var firstName = 'John';
        console.log(firstName);
    })();

    console.log(firstName);

    // john
    // Jane

So firstName in the function is protected from firstName from the global scope.

`require` is a function that takes a path. When you require a module in node, node wraps the code in your module within an IIFE. This protects the variable in a new scope, which is then passed into the v8 engine. module.exports is then returned.

If require() cannot find a file that matches it's string argument it then looks for a folder of the same name. Then it will look for an index.js file within that folder. So you can require a number of files in the index.js, and include there return values in one module.exports object. Then, from say app.js, just require the folder that index.js lives in. You can run functions from any of the original files from a single object. 

If `require()` is given the path of a JSON file (wich is really just a text file in JSON format - no methods and property names/keys in quotes), then that JSON string is returned back as a JSON object. 



